# -*- coding: utf-8 -*-
"""Untitled

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NVPs18xDEwYLVjygQXEnCmEHy5PTbAjl
"""

from typing import List, Optional
import csv
import statistics

class Menu:
    """Collection of Meal objects. Supports parsing, filtering, and basic stats.

    Example:
        >>> csv_text = "id,name,price,calories,diet,flavor\\n1,Pasta,12.5,550,vegetarian,creamy"
        >>> menu = Menu.from_csv(csv_text)
        >>> menu.average_price()
        12.5
    """

    def __init__(self, meals: Optional[List[Meal]] = None):
        self._meals: List[Meal] = meals or []

    # --- Alternate constructor ---
    @classmethod
    def from_csv(cls, csv_text: str) -> "Menu":
        """Parse CSV text and return a Menu object."""
        if not isinstance(csv_text, str):
            raise TypeError("Menu.from_csv: csv_text must be a string")
        lines = csv_text.strip().splitlines()
        reader = csv.DictReader(lines)
        meals: List[Meal] = []
        for row in reader:
            try:
                m = Meal(
                    meal_id=row["id"].strip(),
                    name=row["name"].strip(),
                    price=float(row["price"]),
                    calories=int(float(row["calories"])),
                    diet=row["diet"].strip(),
                    flavor=row["flavor"].strip(),
                )
                meals.append(m)
            except Exception:
                continue
        return cls(meals)

    # --- Core methods ---
    def filter_by_diet(self, restriction: str) -> List[Meal]:
        """Return meals matching a dietary restriction (case-insensitive)."""
        if not isinstance(restriction, str):
            raise TypeError("Restriction must be a string.")
        key = restriction.lower().strip()
        return [m for m in self._meals if key in m.diet.lower()]

    def filter_by_price(self, max_price: float) -> List[Meal]:
        """Return meals at or below max_price."""
        if not isinstance(max_price, (int, float)) or max_price < 0:
            raise ValueError("max_price must be non-negative.")
        return [m for m in self._meals if m.price <= float(max_price)]

    def average_price(self) -> float:
        """Return average price of all meals in menu."""
        prices = [m.price for m in self._meals]
        return float(statistics.mean(prices)) if prices else 0.0

    def count_vegetarian(self) -> int:
        """Count how many meals are vegetarian."""
        return sum(1 for m in self._meals if "vegetarian" in m.diet.lower())

    # --- Magic methods for iteration and representation ---
    def __len__(self):
        return len(self._meals)

    def __iter__(self):
        return iter(self._meals)

    def __str__(self):
        return f"Menu with {len(self._meals)} meals"

    def __repr__(self):
        return f"Menu(meals={len(self._meals)})"